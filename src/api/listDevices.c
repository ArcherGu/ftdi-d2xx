#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "api/listDevices.h"
#include "error_check.h"
#include "module_data.h"
#include "ftd2xx.h"


// This function runs on a worker thread.
// It has no access to the JavaScript. Only FTDI functions are called here.
static void execute_callback(napi_env env, void* data) {
  module_data_t* module_data = (module_data_t*) data;
  DWORD nb_devices = 0;

  // Reinitialize module data
  module_data->return_buffer = NULL;
  module_data->count_buffer = 0;

  // Create FTDI device info list
  error_check(env, FT_CreateDeviceInfoList(&nb_devices) == FT_OK);

  // If devices are detected, query device info
  if(nb_devices > 0) {

    // Allocate dynamic memory for device info list based on nb_devices
    FT_DEVICE_LIST_INFO_NODE* device_info_list = malloc(sizeof(FT_DEVICE_LIST_INFO_NODE) * nb_devices);
    
    // Fill the allocated memory with the list of device info
    error_check(env, FT_GetDeviceInfoList(device_info_list, &nb_devices) == FT_OK);

    // Write the allocated memory pointer and the number of devices in the module data
    module_data->return_buffer = device_info_list;
    module_data->count_buffer = nb_devices;
  }
}


// This function runs on the main thread after `execute_callback` exits.
// JavaScript functions are called here to wrap data generated by FTDI.
static void complete_callback(napi_env env, napi_status status, void* data) {
  if(status != napi_ok) return;
  module_data_t* module_data = (module_data_t*) data;

  // Get JavaScript `true` and `false` constants
  napi_value napi_bool_true, napi_bool_false;
  error_check(env, napi_get_boolean(env, true, &napi_bool_true) == napi_ok);
  error_check(env, napi_get_boolean(env, false, &napi_bool_false) == napi_ok);

  // Get Device class from its reference
  napi_value device_class;
  status = napi_get_reference_value(env, module_data->device_class_ref, &device_class);

  // Get device array from its reference
  napi_value devices_array;
  status = napi_get_reference_value(env, module_data->devices_array_ref, &devices_array);

  // Get device array length
  uint32_t devices_array_length = 0;
  status = napi_get_array_length(env, devices_array, &devices_array_length);

  // Reset current devices `isConnected` flag
  for(uint32_t i = 0; i < devices_array_length; i++) {
    napi_value dev_obj;
    error_check(env, napi_get_element(env, devices_array, i, &dev_obj) == napi_ok);
    error_check(env, napi_set_named_property(env, dev_obj, "isConnected", napi_bool_false) == napi_ok);
  }

  // Get device info list allocated by FTDI in the `execute_callback` function
  FT_DEVICE_LIST_INFO_NODE* device_info_list = module_data->return_buffer;

  // Check that a device info list was allocated (no allocation if no devices were detected)
  if(module_data->count_buffer && device_info_list) {

    // Browse the new connected devices from the list returned by FTDI FT_GetDeviceInfoList
    for(uint32_t i = 0; i < module_data->count_buffer; i++) {
      FT_DEVICE_LIST_INFO_NODE device_info = device_info_list[i];
      napi_value device_object = NULL;

      // Encode values returned by FTDI FT_GetDeviceInfoList in JavaScript
      napi_value SerialNumber, Description;
      error_check(env, napi_create_string_utf8(env, device_info.SerialNumber, sizeof(device_info.SerialNumber), &SerialNumber) == napi_ok);
      error_check(env, napi_create_string_utf8(env, device_info.Description, sizeof(device_info.Description), &Description) == napi_ok);

      // Find the JS device object if it was previously discovered, based on its serial number
      for(uint32_t j = 0; j < devices_array_length; j++) {
        napi_value dev_obj;
        napi_value dev_sn;
        bool is_found;
        error_check(env, napi_get_element(env, devices_array, i, &dev_obj) == napi_ok);
        error_check(env, napi_get_named_property(env, dev_obj, "SerialNumber", &dev_sn) == napi_ok);
        error_check(env, napi_strict_equals(env, dev_sn, SerialNumber, &is_found) == napi_ok);
        if(is_found) {
          device_object = dev_obj;
          break;
        }
      }

      // If not, create a new JavaScript Device object, fill it with class methods, and add it to the list
      if(!device_object) {
        //error_check(env, napi_create_object(env, &device_object) == napi_ok);
        error_check(env, napi_new_instance(env, device_class, 0, NULL, &device_object) == napi_ok);
        napi_set_element(env, devices_array, devices_array_length++, device_object);
      }

      // Set the device object with new info returned by FTDI FT_GetDeviceInfoList
      error_check(env, napi_set_named_property(env, device_object, "isConnected", napi_bool_true) == napi_ok);
      error_check(env, napi_set_named_property(env, device_object, "SerialNumber", SerialNumber) == napi_ok);
      error_check(env, napi_set_named_property(env, device_object, "Description", Description) == napi_ok);

      // printf("Dev %d:\n", i);
      // printf("  Flags=0x%x\n", device_info.Flags);
      // printf("  Type=0x%x\n", device_info.Type);
      // printf("  ID=0x%x\n", device_info.ID);
      // printf("  LocId=0x%x\n", device_info.LocId);
      // printf("  SerialNumber=%s\n", device_info.SerialNumber);
      // printf("  Description=%s\n", device_info.Description);
      // printf("  ftHandle=0x%x\n", device_info.ftHandle);

    }

    // Free previously allocated memory
    free(device_info_list);
    module_data->return_buffer = NULL;
  }

  // Resolve the JavaScript Promise with the return value
  error_check(env, napi_resolve_deferred(env, module_data->deferred, devices_array) == napi_ok);

  // Clean up the work item associated with this run
  error_check(env, napi_delete_async_work(env, module_data->async_work) == napi_ok);

  // Set both values to NULL so JavaScript can order a new run of the thread.
  module_data->async_work = NULL;
  module_data->deferred = NULL;
}


// Create a deferred JavaScript Promise and an async queue work item
napi_value listDevices(napi_env env, napi_callback_info info) {
  
  // Get the global module data
  module_data_t* module_data;
  error_check(env, napi_get_cb_info(env, info, NULL, NULL, NULL, (void**)(&module_data)) == napi_ok);

  // Ensure that no work is currently in progress
  if(module_data->async_work != NULL) napi_throw_error(env, NULL, "Only one work item must exist at a time");

  // Create a deferred promise which we will resolve at the completion of the work
  napi_value promise;
  error_check(env, napi_create_promise(env, &(module_data->deferred), &promise) == napi_ok);

  // Create an async work item, passing in the addon data, which will give the
  // worker thread access to the Promise
  napi_value name;
  error_check(env, napi_create_string_utf8(env, "listDevices", NAPI_AUTO_LENGTH, &name) == napi_ok);
  error_check(env, napi_create_async_work(env, NULL, name, execute_callback, complete_callback, module_data, &(module_data->async_work)) == napi_ok);

  // Queue the work item for execution
  error_check(env, napi_queue_async_work(env, module_data->async_work) == napi_ok);

  // This causes created `promise` to be returned to JavaScript
  return promise;
}
